{
  "id": "services-introduction",
  "moduleId": "fundamentals",
  "title": "Services Introduction",
  "content": "<h2>Angular Services and Dependency Injection</h2><p>Services are a fundamental part of Angular applications, providing a way to organize and share code across components. They handle business logic, data access, and other functionality that doesn't belong in components, following the principle of separation of concerns.</p><h3>What are Services?</h3><p>Services are TypeScript classes that:</p><ul><li>Encapsulate business logic and data operations</li><li>Provide functionality that can be shared across components</li><li>Handle communication with external APIs</li><li>Manage application state</li><li>Perform calculations and data transformations</li></ul><h3>Dependency Injection</h3><p>Angular's dependency injection (DI) system provides services to components and other services. DI offers several benefits:</p><ul><li><strong>Modularity:</strong> Services can be easily swapped or modified</li><li><strong>Testability:</strong> Services can be mocked for unit testing</li><li><strong>Reusability:</strong> The same service can be used across multiple components</li><li><strong>Singleton Pattern:</strong> Services are typically singletons (one instance per injector)</li></ul><h3>Service Registration</h3><p>Services can be registered at different levels:</p><ul><li><strong>Root level:</strong> <code>providedIn: 'root'</code> - Available throughout the application</li><li><strong>Module level:</strong> Provided in the module's providers array</li><li><strong>Component level:</strong> Provided in the component's providers array</li></ul><h3>Creating Services</h3><p>Services are created using the <code>@Injectable()</code> decorator and can be generated using Angular CLI:</p><code>ng generate service my-service</code><h3>Common Service Patterns</h3><ul><li><strong>Data Services:</strong> Handle API calls and data management</li><li><strong>Utility Services:</strong> Provide common functionality like formatting</li><li><strong>State Management Services:</strong> Manage application state with BehaviorSubject</li><li><strong>Communication Services:</strong> Enable component-to-component communication</li></ul><h3>Best Practices</h3><ul><li>Keep services focused on a single responsibility</li><li>Use TypeScript interfaces for type safety</li><li>Handle errors appropriately in service methods</li><li>Use RxJS observables for asynchronous operations</li><li>Provide services at the appropriate level</li></ul>",
  "codeExamples": [
    {
      "id": "basic-service",
      "title": "Creating a Basic Service",
      "description": "Learn how to create a simple service with the @Injectable decorator and basic methods.",
      "code": "// user.service.ts\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  role: string;\n  isActive: boolean;\n}\n\n@Injectable({\n  providedIn: 'root' // Makes service available throughout the app\n})\nexport class UserService {\n  // Private data that only the service can modify\n  private users: User[] = [\n    { id: 1, name: 'John Doe', email: 'john@example.com', role: 'admin', isActive: true },\n    { id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'user', isActive: true },\n    { id: 3, name: 'Mike Johnson', email: 'mike@example.com', role: 'user', isActive: false }\n  ];\n  \n  private currentUserSubject = new BehaviorSubject<User | null>(null);\n  public currentUser$ = this.currentUserSubject.asObservable();\n  \n  // Constructor can inject other services\n  constructor() {\n    console.log('UserService initialized');\n  }\n  \n  // Get all users\n  getAllUsers(): User[] {\n    return [...this.users]; // Return a copy to prevent external modification\n  }\n  \n  // Get user by ID\n  getUserById(id: number): User | undefined {\n    return this.users.find(user => user.id === id);\n  }\n  \n  // Add new user\n  addUser(user: Omit<User, 'id'>): User {\n    const newUser: User = {\n      ...user,\n      id: this.getNextId()\n    };\n    this.users.push(newUser);\n    return newUser;\n  }\n  \n  // Update existing user\n  updateUser(id: number, updates: Partial<User>): User | null {\n    const userIndex = this.users.findIndex(user => user.id === id);\n    if (userIndex !== -1) {\n      this.users[userIndex] = { ...this.users[userIndex], ...updates };\n      return this.users[userIndex];\n    }\n    return null;\n  }\n  \n  // Delete user\n  deleteUser(id: number): boolean {\n    const userIndex = this.users.findIndex(user => user.id === id);\n    if (userIndex !== -1) {\n      this.users.splice(userIndex, 1);\n      return true;\n    }\n    return false;\n  }\n  \n  // Set current user (for login simulation)\n  setCurrentUser(user: User): void {\n    this.currentUserSubject.next(user);\n  }\n  \n  // Clear current user (for logout)\n  clearCurrentUser(): void {\n    this.currentUserSubject.next(null);\n  }\n  \n  // Get current user synchronously\n  getCurrentUser(): User | null {\n    return this.currentUserSubject.value;\n  }\n  \n  // Utility methods\n  private getNextId(): number {\n    return Math.max(...this.users.map(u => u.id), 0) + 1;\n  }\n  \n  // Filter users by role\n  getUsersByRole(role: string): User[] {\n    return this.users.filter(user => user.role === role);\n  }\n  \n  // Get active users count\n  getActiveUsersCount(): number {\n    return this.users.filter(user => user.isActive).length;\n  }\n  \n  // Search users by name or email\n  searchUsers(query: string): User[] {\n    const lowercaseQuery = query.toLowerCase();\n    return this.users.filter(user => \n      user.name.toLowerCase().includes(lowercaseQuery) ||\n      user.email.toLowerCase().includes(lowercaseQuery)\n    );\n  }\n}\n\n// Using the service in a component\n// user-list.component.ts\nimport { Component, OnInit, OnDestroy } from '@angular/core';\nimport { UserService } from './user.service';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-user-list',\n  template: `\n    <div class=\"user-list\">\n      <h3>Users ({{ users.length }})</h3>\n      \n      <div *ngIf=\"currentUser\" class=\"current-user\">\n        <p>Logged in as: {{ currentUser.name }} ({{ currentUser.role }})</p>\n        <button (click)=\"logout()\">Logout</button>\n      </div>\n      \n      <div class=\"user-stats\">\n        <p>Active Users: {{ activeUsersCount }}</p>\n        <p>Admin Users: {{ adminUsers.length }}</p>\n      </div>\n      \n      <input \n        type=\"text\" \n        [(ngModel)]=\"searchQuery\"\n        (input)=\"onSearch()\"\n        placeholder=\"Search users...\">\n      \n      <div *ngFor=\"let user of filteredUsers\" class=\"user-item\">\n        <h4>{{ user.name }}</h4>\n        <p>{{ user.email }} - {{ user.role }}</p>\n        <p>Status: {{ user.isActive ? 'Active' : 'Inactive' }}</p>\n        <button (click)=\"loginAs(user)\">Login as {{ user.name }}</button>\n        <button (click)=\"toggleUserStatus(user.id)\">Toggle Status</button>\n        <button (click)=\"deleteUser(user.id)\">Delete</button>\n      </div>\n    </div>\n  `\n})\nexport class UserListComponent implements OnInit, OnDestroy {\n  users: User[] = [];\n  filteredUsers: User[] = [];\n  currentUser: User | null = null;\n  adminUsers: User[] = [];\n  activeUsersCount = 0;\n  searchQuery = '';\n  \n  private subscription = new Subscription();\n  \n  constructor(private userService: UserService) {}\n  \n  ngOnInit() {\n    // Load initial data\n    this.loadUsers();\n    \n    // Subscribe to current user changes\n    this.subscription.add(\n      this.userService.currentUser$.subscribe(user => {\n        this.currentUser = user;\n      })\n    );\n  }\n  \n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n  \n  loadUsers() {\n    this.users = this.userService.getAllUsers();\n    this.filteredUsers = [...this.users];\n    this.adminUsers = this.userService.getUsersByRole('admin');\n    this.activeUsersCount = this.userService.getActiveUsersCount();\n  }\n  \n  onSearch() {\n    if (this.searchQuery.trim()) {\n      this.filteredUsers = this.userService.searchUsers(this.searchQuery);\n    } else {\n      this.filteredUsers = [...this.users];\n    }\n  }\n  \n  loginAs(user: User) {\n    this.userService.setCurrentUser(user);\n  }\n  \n  logout() {\n    this.userService.clearCurrentUser();\n  }\n  \n  toggleUserStatus(userId: number) {\n    const user = this.userService.getUserById(userId);\n    if (user) {\n      this.userService.updateUser(userId, { isActive: !user.isActive });\n      this.loadUsers(); // Refresh data\n      this.onSearch(); // Refresh filtered data\n    }\n  }\n  \n  deleteUser(userId: number) {\n    if (confirm('Are you sure you want to delete this user?')) {\n      this.userService.deleteUser(userId);\n      this.loadUsers(); // Refresh data\n      this.onSearch(); // Refresh filtered data\n    }\n  }\n}",
      "language": "typescript",
      "isEditable": true,
      "explanation": "This basic service demonstrates key concepts: @Injectable decorator, providedIn: 'root', data management, methods for CRUD operations, and integration with components through dependency injection.",
      "expectedOutput": "A functional user management system with service-based data operations and component integration"
    },
    {
      "id": "http-service",
      "title": "HTTP Service with API Integration",
      "description": "Create a service that communicates with external APIs using Angular's HttpClient.",
      "code": "// api.service.ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';\nimport { Observable, throwError, BehaviorSubject, of } from 'rxjs';\nimport { catchError, map, tap, delay, retry } from 'rxjs/operators';\n\ninterface Post {\n  id: number;\n  title: string;\n  body: string;\n  userId: number;\n}\n\ninterface Comment {\n  id: number;\n  postId: number;\n  name: string;\n  email: string;\n  body: string;\n}\n\ninterface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  message: string;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ApiService {\n  private readonly baseUrl = 'https://jsonplaceholder.typicode.com';\n  private loadingSubject = new BehaviorSubject<boolean>(false);\n  public loading$ = this.loadingSubject.asObservable();\n  \n  private httpOptions = {\n    headers: new HttpHeaders({\n      'Content-Type': 'application/json',\n      'Accept': 'application/json'\n    })\n  };\n  \n  constructor(private http: HttpClient) {\n    console.log('ApiService initialized');\n  }\n  \n  // Generic GET request with error handling\n  private get<T>(endpoint: string): Observable<T> {\n    this.setLoading(true);\n    \n    return this.http.get<T>(`${this.baseUrl}${endpoint}`, this.httpOptions)\n      .pipe(\n        retry(2), // Retry failed requests twice\n        tap(() => this.setLoading(false)),\n        catchError(this.handleError)\n      );\n  }\n  \n  // Generic POST request\n  private post<T>(endpoint: string, data: any): Observable<T> {\n    this.setLoading(true);\n    \n    return this.http.post<T>(`${this.baseUrl}${endpoint}`, data, this.httpOptions)\n      .pipe(\n        tap(() => this.setLoading(false)),\n        catchError(this.handleError)\n      );\n  }\n  \n  // Generic PUT request\n  private put<T>(endpoint: string, data: any): Observable<T> {\n    this.setLoading(true);\n    \n    return this.http.put<T>(`${this.baseUrl}${endpoint}`, data, this.httpOptions)\n      .pipe(\n        tap(() => this.setLoading(false)),\n        catchError(this.handleError)\n      );\n  }\n  \n  // Generic DELETE request\n  private delete<T>(endpoint: string): Observable<T> {\n    this.setLoading(true);\n    \n    return this.http.delete<T>(`${this.baseUrl}${endpoint}`, this.httpOptions)\n      .pipe(\n        tap(() => this.setLoading(false)),\n        catchError(this.handleError)\n      );\n  }\n  \n  // Posts API methods\n  getAllPosts(): Observable<Post[]> {\n    return this.get<Post[]>('/posts')\n      .pipe(\n        map(posts => posts.slice(0, 10)), // Limit to first 10 posts\n        tap(posts => console.log(`Loaded ${posts.length} posts`))\n      );\n  }\n  \n  getPostById(id: number): Observable<Post> {\n    return this.get<Post>(`/posts/${id}`);\n  }\n  \n  getPostsByUserId(userId: number): Observable<Post[]> {\n    return this.get<Post[]>(`/posts?userId=${userId}`);\n  }\n  \n  createPost(post: Omit<Post, 'id'>): Observable<Post> {\n    return this.post<Post>('/posts', post)\n      .pipe(\n        tap(newPost => console.log('Created post:', newPost))\n      );\n  }\n  \n  updatePost(id: number, post: Partial<Post>): Observable<Post> {\n    return this.put<Post>(`/posts/${id}`, post)\n      .pipe(\n        tap(updatedPost => console.log('Updated post:', updatedPost))\n      );\n  }\n  \n  deletePost(id: number): Observable<any> {\n    return this.delete<any>(`/posts/${id}`)\n      .pipe(\n        tap(() => console.log(`Deleted post ${id}`))\n      );\n  }\n  \n  // Comments API methods\n  getCommentsByPostId(postId: number): Observable<Comment[]> {\n    return this.get<Comment[]>(`/posts/${postId}/comments`);\n  }\n  \n  // Search posts (simulated with filtering)\n  searchPosts(query: string): Observable<Post[]> {\n    return this.getAllPosts()\n      .pipe(\n        map(posts => posts.filter(post => \n          post.title.toLowerCase().includes(query.toLowerCase()) ||\n          post.body.toLowerCase().includes(query.toLowerCase())\n        )),\n        delay(500) // Simulate network delay\n      );\n  }\n  \n  // Utility methods\n  private setLoading(loading: boolean): void {\n    this.loadingSubject.next(loading);\n  }\n  \n  private handleError = (error: HttpErrorResponse): Observable<never> => {\n    this.setLoading(false);\n    \n    let errorMessage = 'An unknown error occurred';\n    \n    if (error.error instanceof ErrorEvent) {\n      // Client-side error\n      errorMessage = `Client Error: ${error.error.message}`;\n    } else {\n      // Server-side error\n      errorMessage = `Server Error Code: ${error.status}\\nMessage: ${error.message}`;\n    }\n    \n    console.error('API Error:', errorMessage);\n    return throwError(() => new Error(errorMessage));\n  }\n  \n  // Cache management (simple example)\n  private cache = new Map<string, any>();\n  \n  getCachedPosts(): Observable<Post[]> {\n    const cacheKey = 'all-posts';\n    const cached = this.cache.get(cacheKey);\n    \n    if (cached) {\n      console.log('Returning cached posts');\n      return of(cached);\n    }\n    \n    return this.getAllPosts()\n      .pipe(\n        tap(posts => {\n          this.cache.set(cacheKey, posts);\n          console.log('Posts cached');\n        })\n      );\n  }\n  \n  clearCache(): void {\n    this.cache.clear();\n    console.log('Cache cleared');\n  }\n}\n\n// Using the HTTP service in a component\n// posts.component.ts\nimport { Component, OnInit, OnDestroy } from '@angular/core';\nimport { ApiService } from './api.service';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-posts',\n  template: `\n    <div class=\"posts-container\">\n      <h2>Posts Management</h2>\n      \n      <!-- Loading indicator -->\n      <div *ngIf=\"isLoading\" class=\"loading\">\n        <p>🔄 Loading posts...</p>\n      </div>\n      \n      <!-- Error message -->\n      <div *ngIf=\"errorMessage\" class=\"error\">\n        <p>❌ {{ errorMessage }}</p>\n        <button (click)=\"loadPosts()\">Retry</button>\n      </div>\n      \n      <!-- Search -->\n      <div class=\"search-section\">\n        <input \n          type=\"text\" \n          [(ngModel)]=\"searchQuery\"\n          (keyup.enter)=\"searchPosts()\"\n          placeholder=\"Search posts...\">\n        <button (click)=\"searchPosts()\" [disabled]=\"isLoading\">Search</button>\n        <button (click)=\"loadPosts()\" [disabled]=\"isLoading\">Show All</button>\n        <button (click)=\"loadCachedPosts()\" [disabled]=\"isLoading\">Load Cached</button>\n      </div>\n      \n      <!-- Posts list -->\n      <div class=\"posts-list\">\n        <div *ngFor=\"let post of posts\" class=\"post-item\">\n          <h3>{{ post.title }}</h3>\n          <p>{{ post.body }}</p>\n          <div class=\"post-actions\">\n            <button (click)=\"loadComments(post.id)\" [disabled]=\"isLoading\">\n              Load Comments\n            </button>\n            <button (click)=\"editPost(post)\" [disabled]=\"isLoading\">\n              Edit\n            </button>\n            <button (click)=\"deletePost(post.id)\" [disabled]=\"isLoading\">\n              Delete\n            </button>\n          </div>\n          \n          <!-- Comments -->\n          <div *ngIf=\"postComments[post.id]\" class=\"comments\">\n            <h4>Comments:</h4>\n            <div *ngFor=\"let comment of postComments[post.id]\" class=\"comment\">\n              <strong>{{ comment.name }}</strong> ({{ comment.email }})\n              <p>{{ comment.body }}</p>\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      <!-- Create new post -->\n      <div class=\"create-post\">\n        <h3>Create New Post</h3>\n        <input [(ngModel)]=\"newPost.title\" placeholder=\"Post title\">\n        <textarea [(ngModel)]=\"newPost.body\" placeholder=\"Post content\"></textarea>\n        <button (click)=\"createPost()\" [disabled]=\"isLoading || !newPost.title || !newPost.body\">\n          Create Post\n        </button>\n      </div>\n    </div>\n  `\n})\nexport class PostsComponent implements OnInit, OnDestroy {\n  posts: Post[] = [];\n  postComments: { [postId: number]: Comment[] } = {};\n  isLoading = false;\n  errorMessage = '';\n  searchQuery = '';\n  \n  newPost = {\n    title: '',\n    body: '',\n    userId: 1\n  };\n  \n  private subscriptions = new Subscription();\n  \n  constructor(private apiService: ApiService) {}\n  \n  ngOnInit() {\n    this.loadPosts();\n    \n    // Subscribe to loading state\n    this.subscriptions.add(\n      this.apiService.loading$.subscribe(loading => {\n        this.isLoading = loading;\n      })\n    );\n  }\n  \n  ngOnDestroy() {\n    this.subscriptions.unsubscribe();\n  }\n  \n  loadPosts() {\n    this.errorMessage = '';\n    \n    this.subscriptions.add(\n      this.apiService.getAllPosts().subscribe({\n        next: (posts) => {\n          this.posts = posts;\n          console.log('Posts loaded successfully');\n        },\n        error: (error) => {\n          this.errorMessage = error.message;\n          console.error('Failed to load posts:', error);\n        }\n      })\n    );\n  }\n  \n  loadCachedPosts() {\n    this.subscriptions.add(\n      this.apiService.getCachedPosts().subscribe({\n        next: (posts) => {\n          this.posts = posts;\n        },\n        error: (error) => {\n          this.errorMessage = error.message;\n        }\n      })\n    );\n  }\n  \n  searchPosts() {\n    if (!this.searchQuery.trim()) {\n      this.loadPosts();\n      return;\n    }\n    \n    this.subscriptions.add(\n      this.apiService.searchPosts(this.searchQuery).subscribe({\n        next: (posts) => {\n          this.posts = posts;\n        },\n        error: (error) => {\n          this.errorMessage = error.message;\n        }\n      })\n    );\n  }\n  \n  loadComments(postId: number) {\n    this.subscriptions.add(\n      this.apiService.getCommentsByPostId(postId).subscribe({\n        next: (comments) => {\n          this.postComments[postId] = comments;\n        },\n        error: (error) => {\n          console.error('Failed to load comments:', error);\n        }\n      })\n    );\n  }\n  \n  createPost() {\n    this.subscriptions.add(\n      this.apiService.createPost(this.newPost).subscribe({\n        next: (post) => {\n          this.posts.unshift(post); // Add to beginning of list\n          this.newPost = { title: '', body: '', userId: 1 }; // Reset form\n          console.log('Post created successfully');\n        },\n        error: (error) => {\n          this.errorMessage = error.message;\n        }\n      })\n    );\n  }\n  \n  editPost(post: Post) {\n    const newTitle = prompt('Enter new title:', post.title);\n    if (newTitle && newTitle !== post.title) {\n      this.subscriptions.add(\n        this.apiService.updatePost(post.id, { title: newTitle }).subscribe({\n          next: (updatedPost) => {\n            const index = this.posts.findIndex(p => p.id === post.id);\n            if (index !== -1) {\n              this.posts[index] = updatedPost;\n            }\n          },\n          error: (error) => {\n            this.errorMessage = error.message;\n          }\n        })\n      );\n    }\n  }\n  \n  deletePost(postId: number) {\n    if (confirm('Are you sure you want to delete this post?')) {\n      this.subscriptions.add(\n        this.apiService.deletePost(postId).subscribe({\n          next: () => {\n            this.posts = this.posts.filter(p => p.id !== postId);\n            delete this.postComments[postId];\n          },\n          error: (error) => {\n            this.errorMessage = error.message;\n          }\n        })\n      );\n    }\n  }\n}",
      "language": "typescript",
      "isEditable": true,
      "explanation": "This HTTP service demonstrates API integration with error handling, loading states, caching, retry logic, and proper observable usage. It shows how to create a robust service layer for external data access.",
      "expectedOutput": "A complete API service with CRUD operations, error handling, loading indicators, and caching functionality"
    },
    {
      "id": "state-management-service",
      "title": "State Management Service with RxJS",
      "description": "Create a service for managing application state using RxJS subjects and observables.",
      "code": "// shopping-cart.service.ts\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable, combineLatest } from 'rxjs';\nimport { map, tap } from 'rxjs/operators';\n\ninterface CartItem {\n  id: number;\n  name: string;\n  price: number;\n  quantity: number;\n  image?: string;\n  category: string;\n}\n\ninterface CartState {\n  items: CartItem[];\n  totalItems: number;\n  totalPrice: number;\n  isLoading: boolean;\n  lastUpdated: Date;\n}\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  image?: string;\n  category: string;\n  inStock: boolean;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ShoppingCartService {\n  // Private state subjects\n  private cartItemsSubject = new BehaviorSubject<CartItem[]>([]);\n  private loadingSubject = new BehaviorSubject<boolean>(false);\n  private lastUpdatedSubject = new BehaviorSubject<Date>(new Date());\n  \n  // Public observables\n  public cartItems$ = this.cartItemsSubject.asObservable();\n  public isLoading$ = this.loadingSubject.asObservable();\n  public lastUpdated$ = this.lastUpdatedSubject.asObservable();\n  \n  // Computed observables\n  public totalItems$ = this.cartItems$.pipe(\n    map(items => items.reduce((total, item) => total + item.quantity, 0))\n  );\n  \n  public totalPrice$ = this.cartItems$.pipe(\n    map(items => items.reduce((total, item) => total + (item.price * item.quantity), 0))\n  );\n  \n  public cartSummary$ = combineLatest([\n    this.cartItems$,\n    this.totalItems$,\n    this.totalPrice$,\n    this.isLoading$,\n    this.lastUpdated$\n  ]).pipe(\n    map(([items, totalItems, totalPrice, isLoading, lastUpdated]) => ({\n      items,\n      totalItems,\n      totalPrice,\n      isLoading,\n      lastUpdated\n    } as CartState))\n  );\n  \n  // Cart item count by category\n  public itemsByCategory$ = this.cartItems$.pipe(\n    map(items => {\n      const categories: { [key: string]: number } = {};\n      items.forEach(item => {\n        categories[item.category] = (categories[item.category] || 0) + item.quantity;\n      });\n      return categories;\n    })\n  );\n  \n  // Check if cart is empty\n  public isEmpty$ = this.cartItems$.pipe(\n    map(items => items.length === 0)\n  );\n  \n  // Check if cart has items\n  public hasItems$ = this.cartItems$.pipe(\n    map(items => items.length > 0)\n  );\n  \n  constructor() {\n    // Load cart from localStorage on service initialization\n    this.loadCartFromStorage();\n    \n    // Auto-save cart to localStorage whenever items change\n    this.cartItems$.subscribe(items => {\n      this.saveCartToStorage(items);\n    });\n    \n    console.log('ShoppingCartService initialized');\n  }\n  \n  // Add item to cart\n  addItem(product: Product, quantity: number = 1): void {\n    if (!product.inStock) {\n      console.warn('Cannot add out-of-stock item to cart');\n      return;\n    }\n    \n    this.setLoading(true);\n    \n    // Simulate async operation\n    setTimeout(() => {\n      const currentItems = this.cartItemsSubject.value;\n      const existingItemIndex = currentItems.findIndex(item => item.id === product.id);\n      \n      let updatedItems: CartItem[];\n      \n      if (existingItemIndex >= 0) {\n        // Update existing item quantity\n        updatedItems = currentItems.map((item, index) => \n          index === existingItemIndex \n            ? { ...item, quantity: item.quantity + quantity }\n            : item\n        );\n      } else {\n        // Add new item\n        const newItem: CartItem = {\n          id: product.id,\n          name: product.name,\n          price: product.price,\n          quantity,\n          image: product.image,\n          category: product.category\n        };\n        updatedItems = [...currentItems, newItem];\n      }\n      \n      this.cartItemsSubject.next(updatedItems);\n      this.updateTimestamp();\n      this.setLoading(false);\n      \n      console.log(`Added ${quantity} x ${product.name} to cart`);\n    }, 300);\n  }\n  \n  // Remove item from cart\n  removeItem(productId: number): void {\n    this.setLoading(true);\n    \n    setTimeout(() => {\n      const currentItems = this.cartItemsSubject.value;\n      const updatedItems = currentItems.filter(item => item.id !== productId);\n      \n      this.cartItemsSubject.next(updatedItems);\n      this.updateTimestamp();\n      this.setLoading(false);\n      \n      console.log(`Removed item ${productId} from cart`);\n    }, 200);\n  }\n  \n  // Update item quantity\n  updateQuantity(productId: number, quantity: number): void {\n    if (quantity <= 0) {\n      this.removeItem(productId);\n      return;\n    }\n    \n    this.setLoading(true);\n    \n    setTimeout(() => {\n      const currentItems = this.cartItemsSubject.value;\n      const updatedItems = currentItems.map(item => \n        item.id === productId \n          ? { ...item, quantity }\n          : item\n      );\n      \n      this.cartItemsSubject.next(updatedItems);\n      this.updateTimestamp();\n      this.setLoading(false);\n      \n      console.log(`Updated quantity for item ${productId} to ${quantity}`);\n    }, 200);\n  }\n  \n  // Clear entire cart\n  clearCart(): void {\n    this.setLoading(true);\n    \n    setTimeout(() => {\n      this.cartItemsSubject.next([]);\n      this.updateTimestamp();\n      this.setLoading(false);\n      \n      console.log('Cart cleared');\n    }, 300);\n  }\n  \n  // Get current cart items synchronously\n  getCurrentItems(): CartItem[] {\n    return this.cartItemsSubject.value;\n  }\n  \n  // Get item by ID\n  getItem(productId: number): CartItem | undefined {\n    return this.cartItemsSubject.value.find(item => item.id === productId);\n  }\n  \n  // Check if item is in cart\n  hasItem(productId: number): boolean {\n    return this.cartItemsSubject.value.some(item => item.id === productId);\n  }\n  \n  // Get item quantity\n  getItemQuantity(productId: number): number {\n    const item = this.getItem(productId);\n    return item ? item.quantity : 0;\n  }\n  \n  // Calculate discount (example business logic)\n  calculateDiscount(totalPrice: number): number {\n    if (totalPrice >= 100) return 0.1; // 10% discount for orders over $100\n    if (totalPrice >= 50) return 0.05;  // 5% discount for orders over $50\n    return 0;\n  }\n  \n  // Get discounted total\n  public discountedTotal$ = this.totalPrice$.pipe(\n    map(total => {\n      const discount = this.calculateDiscount(total);\n      return {\n        originalTotal: total,\n        discount: discount,\n        discountAmount: total * discount,\n        finalTotal: total * (1 - discount)\n      };\n    })\n  );\n  \n  // Apply coupon code (simulated)\n  applyCoupon(code: string): Observable<boolean> {\n    return new Observable(observer => {\n      this.setLoading(true);\n      \n      // Simulate API call to validate coupon\n      setTimeout(() => {\n        const validCoupons = ['SAVE10', 'DISCOUNT20', 'FREESHIP'];\n        const isValid = validCoupons.includes(code.toUpperCase());\n        \n        if (isValid) {\n          console.log(`Applied coupon: ${code}`);\n          // In a real app, you'd update cart with coupon discount\n        }\n        \n        this.setLoading(false);\n        observer.next(isValid);\n        observer.complete();\n      }, 1000);\n    });\n  }\n  \n  // Checkout simulation\n  checkout(): Observable<{ success: boolean; orderId?: string; error?: string }> {\n    return new Observable(observer => {\n      this.setLoading(true);\n      \n      // Simulate checkout process\n      setTimeout(() => {\n        const items = this.cartItemsSubject.value;\n        \n        if (items.length === 0) {\n          observer.next({ success: false, error: 'Cart is empty' });\n        } else {\n          // Simulate successful checkout\n          const orderId = 'ORD-' + Date.now();\n          this.clearCart();\n          observer.next({ success: true, orderId });\n        }\n        \n        this.setLoading(false);\n        observer.complete();\n      }, 2000);\n    });\n  }\n  \n  // Private utility methods\n  private setLoading(loading: boolean): void {\n    this.loadingSubject.next(loading);\n  }\n  \n  private updateTimestamp(): void {\n    this.lastUpdatedSubject.next(new Date());\n  }\n  \n  private saveCartToStorage(items: CartItem[]): void {\n    try {\n      localStorage.setItem('shopping-cart', JSON.stringify(items));\n    } catch (error) {\n      console.error('Failed to save cart to localStorage:', error);\n    }\n  }\n  \n  private loadCartFromStorage(): void {\n    try {\n      const saved = localStorage.getItem('shopping-cart');\n      if (saved) {\n        const items = JSON.parse(saved) as CartItem[];\n        this.cartItemsSubject.next(items);\n        console.log('Cart loaded from localStorage');\n      }\n    } catch (error) {\n      console.error('Failed to load cart from localStorage:', error);\n    }\n  }\n}\n\n// Using the state management service\n// cart.component.ts\nimport { Component, OnInit, OnDestroy } from '@angular/core';\nimport { ShoppingCartService } from './shopping-cart.service';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-cart',\n  template: `\n    <div class=\"cart-container\">\n      <h2>Shopping Cart</h2>\n      \n      <!-- Loading indicator -->\n      <div *ngIf=\"(cartService.isLoading$ | async)\" class=\"loading\">\n        Loading...\n      </div>\n      \n      <!-- Empty cart message -->\n      <div *ngIf=\"(cartService.isEmpty$ | async) && !(cartService.isLoading$ | async)\" class=\"empty-cart\">\n        <p>🛒 Your cart is empty</p>\n        <button (click)=\"addSampleItems()\">Add Sample Items</button>\n      </div>\n      \n      <!-- Cart items -->\n      <div *ngIf=\"(cartService.hasItems$ | async)\" class=\"cart-content\">\n        <!-- Cart summary -->\n        <div class=\"cart-summary\">\n          <p><strong>Total Items:</strong> {{ cartService.totalItems$ | async }}</p>\n          <p><strong>Total Price:</strong> ${{ (cartService.totalPrice$ | async) | number:'1.2-2' }}</p>\n          <p><strong>Last Updated:</strong> {{ (cartService.lastUpdated$ | async) | date:'short' }}</p>\n        </div>\n        \n        <!-- Discount info -->\n        <div class=\"discount-info\" *ngIf=\"(cartService.discountedTotal$ | async) as discount\">\n          <p *ngIf=\"discount.discount > 0\" class=\"discount-applied\">\n            🎉 {{ (discount.discount * 100) }}% discount applied! \n            Save ${{ discount.discountAmount | number:'1.2-2' }}\n          </p>\n          <p><strong>Final Total:</strong> ${{ discount.finalTotal | number:'1.2-2' }}</p>\n        </div>\n        \n        <!-- Items by category -->\n        <div class=\"category-summary\">\n          <h4>Items by Category:</h4>\n          <div *ngFor=\"let category of (cartService.itemsByCategory$ | async) | keyvalue\">\n            {{ category.key }}: {{ category.value }} items\n          </div>\n        </div>\n        \n        <!-- Cart items list -->\n        <div class=\"cart-items\">\n          <div *ngFor=\"let item of (cartService.cartItems$ | async)\" class=\"cart-item\">\n            <h4>{{ item.name }}</h4>\n            <p>Price: ${{ item.price | number:'1.2-2' }}</p>\n            <p>Category: {{ item.category }}</p>\n            \n            <div class=\"quantity-controls\">\n              <button (click)=\"decreaseQuantity(item.id)\" [disabled]=\"(cartService.isLoading$ | async)\">-</button>\n              <span class=\"quantity\">{{ item.quantity }}</span>\n              <button (click)=\"increaseQuantity(item.id)\" [disabled]=\"(cartService.isLoading$ | async)\">+</button>\n            </div>\n            \n            <p><strong>Subtotal:</strong> ${{ (item.price * item.quantity) | number:'1.2-2' }}</p>\n            \n            <button (click)=\"removeItem(item.id)\" [disabled]=\"(cartService.isLoading$ | async)\" class=\"remove-btn\">\n              Remove\n            </button>\n          </div>\n        </div>\n        \n        <!-- Cart actions -->\n        <div class=\"cart-actions\">\n          <button (click)=\"clearCart()\" [disabled]=\"(cartService.isLoading$ | async)\" class=\"clear-btn\">\n            Clear Cart\n          </button>\n          \n          <button (click)=\"checkout()\" [disabled]=\"(cartService.isLoading$ | async)\" class=\"checkout-btn\">\n            Checkout\n          </button>\n        </div>\n        \n        <!-- Coupon section -->\n        <div class=\"coupon-section\">\n          <input [(ngModel)]=\"couponCode\" placeholder=\"Enter coupon code\">\n          <button (click)=\"applyCoupon()\" [disabled]=\"(cartService.isLoading$ | async) || !couponCode\">\n            Apply Coupon\n          </button>\n        </div>\n      </div>\n      \n      <!-- Checkout result -->\n      <div *ngIf=\"checkoutResult\" class=\"checkout-result\">\n        <div *ngIf=\"checkoutResult.success\" class=\"success\">\n          ✅ Order placed successfully! Order ID: {{ checkoutResult.orderId }}\n        </div>\n        <div *ngIf=\"!checkoutResult.success\" class=\"error\">\n          ❌ Checkout failed: {{ checkoutResult.error }}\n        </div>\n      </div>\n    </div>\n  `\n})\nexport class CartComponent implements OnInit, OnDestroy {\n  couponCode = '';\n  checkoutResult: any = null;\n  private subscriptions = new Subscription();\n  \n  constructor(public cartService: ShoppingCartService) {}\n  \n  ngOnInit() {\n    // Subscribe to cart changes for logging\n    this.subscriptions.add(\n      this.cartService.cartSummary$.subscribe(summary => {\n        console.log('Cart Summary:', summary);\n      })\n    );\n  }\n  \n  ngOnDestroy() {\n    this.subscriptions.unsubscribe();\n  }\n  \n  addSampleItems() {\n    const sampleProducts: Product[] = [\n      { id: 1, name: 'Laptop', price: 999, category: 'Electronics', inStock: true },\n      { id: 2, name: 'Book', price: 25, category: 'Education', inStock: true },\n      { id: 3, name: 'Coffee Mug', price: 15, category: 'Kitchen', inStock: true }\n    ];\n    \n    sampleProducts.forEach(product => {\n      this.cartService.addItem(product, 1);\n    });\n  }\n  \n  increaseQuantity(productId: number) {\n    const currentQuantity = this.cartService.getItemQuantity(productId);\n    this.cartService.updateQuantity(productId, currentQuantity + 1);\n  }\n  \n  decreaseQuantity(productId: number) {\n    const currentQuantity = this.cartService.getItemQuantity(productId);\n    if (currentQuantity > 1) {\n      this.cartService.updateQuantity(productId, currentQuantity - 1);\n    } else {\n      this.cartService.removeItem(productId);\n    }\n  }\n  \n  removeItem(productId: number) {\n    this.cartService.removeItem(productId);\n  }\n  \n  clearCart() {\n    if (confirm('Are you sure you want to clear the cart?')) {\n      this.cartService.clearCart();\n    }\n  }\n  \n  applyCoupon() {\n    this.subscriptions.add(\n      this.cartService.applyCoupon(this.couponCode).subscribe(isValid => {\n        if (isValid) {\n          alert('Coupon applied successfully!');\n          this.couponCode = '';\n        } else {\n          alert('Invalid coupon code');\n        }\n      })\n    );\n  }\n  \n  checkout() {\n    this.subscriptions.add(\n      this.cartService.checkout().subscribe(result => {\n        this.checkoutResult = result;\n        \n        // Clear result after 5 seconds\n        setTimeout(() => {\n          this.checkoutResult = null;\n        }, 5000);\n      })\n    );\n  }\n}",
      "language": "typescript",
      "isEditable": true,
      "explanation": "This state management service demonstrates advanced patterns with RxJS: BehaviorSubjects for state, computed observables, localStorage persistence, and reactive programming patterns for complex application state.",
      "expectedOutput": "A fully functional shopping cart with reactive state management, persistence, and advanced RxJS patterns"
    }
  ],
  "order": 4,
  "tags": ["services", "dependency-injection", "providers", "http", "rxjs", "state-management"],
  "difficulty": "intermediate",
  "estimatedTime": "50 min",
  "exercises": [
    {
      "id": "notification-service",
      "title": "Build a Notification Service",
      "description": "Create a comprehensive notification service that manages different types of notifications:",
      "tasks": [
        "Create a notification service with different message types (success, error, warning, info)",
        "Implement auto-dismiss functionality with configurable timeouts",
        "Add notification persistence using localStorage",
        "Create a notification history feature",
        "Implement notification actions (clickable notifications)",
        "Add notification templates for common scenarios",
        "Include notification positioning and animation options",
        "Build a component to display and manage notifications"
      ],
      "expectedResult": "A production-ready notification system that can be used throughout an Angular application"
    }
  ]
}