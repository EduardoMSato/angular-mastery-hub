{
  "id": "component-lifecycle",
  "moduleId": "core-concepts",
  "title": "Component Lifecycle Hooks",
  "order": 1,
  "content": "Angular components have a well-defined lifecycle managed by Angular. During this lifecycle, Angular creates, renders, creates and destroys its children, and destroys the component instance before removing its template from the DOM.\n\nLifecycle hooks give you the opportunity to act at key moments in a component's lifecycle. Each interface has a single hook method whose name is the interface name prefixed with 'ng'.",
  "estimatedTime": "30 minutes",
  "objectives": [
    "Understand the component lifecycle sequence",
    "Learn when and how to use lifecycle hooks",
    "Master ngOnInit, ngOnDestroy, and ngOnChanges",
    "Handle component initialization and cleanup"
  ],
  "codeExamples": [
    {
      "title": "Complete Lifecycle Example",
      "language": "typescript",
      "code": "import { Component, OnInit, OnDestroy, OnChanges, AfterViewInit, Input, SimpleChanges } from '@angular/core';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-lifecycle-demo',\n  template: `\n    <div class=\"lifecycle-demo\">\n      <h3>Component: {{ name }}</h3>\n      <p>Counter: {{ counter }}</p>\n      <button (click)=\"increment()\">Increment</button>\n      <div #viewChild class=\"view-child\">View Child Element</div>\n    </div>\n  `,\n  styles: [`\n    .lifecycle-demo {\n      padding: 20px;\n      border: 2px solid #007bff;\n      border-radius: 8px;\n      margin: 10px;\n    }\n    .view-child {\n      background: #f8f9fa;\n      padding: 10px;\n      margin-top: 10px;\n      border-radius: 4px;\n    }\n  `]\n})\nexport class LifecycleDemoComponent implements OnInit, OnDestroy, OnChanges, AfterViewInit {\n  @Input() name = 'Demo Component';\n  \n  counter = 0;\n  private subscription = new Subscription();\n\n  constructor() {\n    console.log('Constructor: Component instance created');\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    console.log('ngOnChanges: Input properties changed', changes);\n    \n    if (changes['name']) {\n      console.log(`Name changed from ${changes['name'].previousValue} to ${changes['name'].currentValue}`);\n    }\n  }\n\n  ngOnInit(): void {\n    console.log('ngOnInit: Component initialized');\n    \n    // Perfect place for:\n    // - HTTP requests\n    // - Setting up subscriptions\n    // - Initial data loading\n    this.loadInitialData();\n  }\n\n  ngAfterViewInit(): void {\n    console.log('ngAfterViewInit: View fully initialized');\n    \n    // Perfect place for:\n    // - DOM manipulation\n    // - Third-party library initialization\n    // - ViewChild access\n  }\n\n  ngOnDestroy(): void {\n    console.log('ngOnDestroy: Component about to be destroyed');\n    \n    // Critical for:\n    // - Cleaning up subscriptions\n    // - Removing event listeners\n    // - Canceling timers\n    this.subscription.unsubscribe();\n  }\n\n  increment(): void {\n    this.counter++;\n  }\n\n  private loadInitialData(): void {\n    // Simulate data loading\n    console.log('Loading initial data...');\n  }\n}",
      "explanation": "This example demonstrates the most commonly used lifecycle hooks and their typical use cases."
    },
    {
      "title": "Lifecycle Hook Sequence",
      "language": "typescript",
      "code": "import { Component, OnInit, OnDestroy, OnChanges, AfterContentInit, AfterContentChecked, AfterViewInit, AfterViewChecked, DoCheck } from '@angular/core';\n\n@Component({\n  selector: 'app-hook-sequence',\n  template: `\n    <div class=\"hook-sequence\">\n      <h4>Lifecycle Hook Sequence Logger</h4>\n      <p>Check the console to see the hook execution order</p>\n      <ul>\n        <li *ngFor=\"let log of hookLogs\">{{ log }}</li>\n      </ul>\n    </div>\n  `\n})\nexport class HookSequenceComponent implements OnInit, OnDestroy, OnChanges, \n  AfterContentInit, AfterContentChecked, AfterViewInit, AfterViewChecked, DoCheck {\n  \n  hookLogs: string[] = [];\n  private checkCount = 0;\n\n  constructor() {\n    this.log('Constructor');\n  }\n\n  ngOnChanges(): void {\n    this.log('ngOnChanges');\n  }\n\n  ngOnInit(): void {\n    this.log('ngOnInit');\n  }\n\n  ngDoCheck(): void {\n    this.checkCount++;\n    if (this.checkCount <= 3) { // Limit logs to avoid spam\n      this.log(`ngDoCheck (${this.checkCount})`);\n    }\n  }\n\n  ngAfterContentInit(): void {\n    this.log('ngAfterContentInit');\n  }\n\n  ngAfterContentChecked(): void {\n    if (this.checkCount <= 3) {\n      this.log('ngAfterContentChecked');\n    }\n  }\n\n  ngAfterViewInit(): void {\n    this.log('ngAfterViewInit');\n  }\n\n  ngAfterViewChecked(): void {\n    if (this.checkCount <= 3) {\n      this.log('ngAfterViewChecked');\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.log('ngOnDestroy');\n  }\n\n  private log(hookName: string): void {\n    const timestamp = new Date().toLocaleTimeString();\n    const logEntry = `${timestamp}: ${hookName}`;\n    this.hookLogs.push(logEntry);\n    console.log(logEntry);\n  }\n}",
      "explanation": "This component logs the execution order of all lifecycle hooks to help understand the sequence."
    }
  ],
  "exercises": [
    {
      "title": "Build a Timer Component with Lifecycle Management",
      "description": "Create a timer component that properly manages its interval using lifecycle hooks.",
      "hints": [
        "Use ngOnInit to start the timer",
        "Use ngOnDestroy to clean up the interval",
        "Store the interval ID to clear it later",
        "Consider using OnPush change detection",
        "Add start/stop/reset functionality"
      ],
      "solution": "import { Component, OnInit, OnDestroy, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';\n\n@Component({\n  selector: 'app-timer',\n  template: `\n    <div class=\"timer-component\">\n      <div class=\"timer-display\">\n        <h2>{{ formatTime(seconds) }}</h2>\n      </div>\n      <div class=\"timer-controls\">\n        <button (click)=\"start()\" [disabled]=\"isRunning\">Start</button>\n        <button (click)=\"stop()\" [disabled]=\"!isRunning\">Stop</button>\n        <button (click)=\"reset()\">Reset</button>\n      </div>\n      <div class=\"timer-info\">\n        <p>Status: {{ isRunning ? 'Running' : 'Stopped' }}</p>\n        <p>Laps: {{ lapCount }}</p>\n        <button (click)=\"lap()\" [disabled]=\"!isRunning\">Lap</button>\n        <ul class=\"lap-times\">\n          <li *ngFor=\"let lapTime of lapTimes; let i = index\">\n            Lap {{ i + 1 }}: {{ formatTime(lapTime) }}\n          </li>\n        </ul>\n      </div>\n    </div>\n  `,\n  styles: [`\n    .timer-component {\n      text-align: center;\n      padding: 20px;\n      border: 2px solid #28a745;\n      border-radius: 12px;\n      max-width: 400px;\n      margin: 20px auto;\n    }\n    .timer-display h2 {\n      font-family: 'Courier New', monospace;\n      font-size: 3em;\n      margin: 20px 0;\n      color: #28a745;\n    }\n    .timer-controls {\n      margin: 20px 0;\n    }\n    .timer-controls button {\n      margin: 0 10px;\n      padding: 10px 20px;\n      font-size: 1em;\n      border: none;\n      border-radius: 6px;\n      cursor: pointer;\n      transition: background-color 0.2s;\n    }\n    .timer-controls button:not(:disabled) {\n      background: #007bff;\n      color: white;\n    }\n    .timer-controls button:disabled {\n      background: #ccc;\n      cursor: not-allowed;\n    }\n    .lap-times {\n      text-align: left;\n      max-height: 200px;\n      overflow-y: auto;\n    }\n  `],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class TimerComponent implements OnInit, OnDestroy {\n  seconds = 0;\n  isRunning = false;\n  lapCount = 0;\n  lapTimes: number[] = [];\n  private intervalId: number | null = null;\n\n  constructor(private cdr: ChangeDetectorRef) {}\n\n  ngOnInit(): void {\n    console.log('Timer component initialized');\n    // Could auto-start timer here if needed\n  }\n\n  ngOnDestroy(): void {\n    console.log('Timer component destroyed - cleaning up interval');\n    this.clearInterval();\n  }\n\n  start(): void {\n    if (!this.isRunning) {\n      this.isRunning = true;\n      this.intervalId = window.setInterval(() => {\n        this.seconds++;\n        this.cdr.markForCheck(); // Trigger change detection for OnPush\n      }, 1000);\n    }\n  }\n\n  stop(): void {\n    this.isRunning = false;\n    this.clearInterval();\n  }\n\n  reset(): void {\n    this.stop();\n    this.seconds = 0;\n    this.lapCount = 0;\n    this.lapTimes = [];\n    this.cdr.markForCheck();\n  }\n\n  lap(): void {\n    if (this.isRunning) {\n      this.lapCount++;\n      this.lapTimes.push(this.seconds);\n      this.cdr.markForCheck();\n    }\n  }\n\n  formatTime(totalSeconds: number): string {\n    const hours = Math.floor(totalSeconds / 3600);\n    const minutes = Math.floor((totalSeconds % 3600) / 60);\n    const seconds = totalSeconds % 60;\n    \n    if (hours > 0) {\n      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n    }\n    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n  }\n\n  private clearInterval(): void {\n    if (this.intervalId !== null) {\n      window.clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n  }\n}"
    }
  ],
  "nextSection": "dependency-injection",
  "previousSection": null
}