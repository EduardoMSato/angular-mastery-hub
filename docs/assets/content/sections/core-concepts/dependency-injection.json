{
  "id": "dependency-injection",
  "moduleId": "core-concepts",
  "title": "Dependency Injection in Angular",
  "order": 2,
  "content": "Dependency Injection (DI) is a design pattern and mechanism for creating and delivering some parts of an application to other parts that require them. Angular has its own DI framework, which is typically used in the design of Angular applications to increase their efficiency and modularity.\n\nDependencies are services or objects that a class needs to perform its function. DI is a coding pattern in which a class asks for dependencies from external sources rather than creating them itself.",
  "estimatedTime": "35 minutes",
  "objectives": [
    "Understand the dependency injection pattern",
    "Learn about Angular's DI system and injectors",
    "Master service creation and injection",
    "Explore different injection scopes and providers"
  ],
  "codeExamples": [
    {
      "title": "Creating and Injecting Services",
      "language": "typescript",
      "code": "// user.service.ts\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nexport interface User {\n  id: number;\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n}\n\n@Injectable({\n  providedIn: 'root' // This creates a singleton instance\n})\nexport class UserService {\n  private usersSubject = new BehaviorSubject<User[]>([]);\n  public users$ = this.usersSubject.asObservable();\n  \n  private currentUserSubject = new BehaviorSubject<User | null>(null);\n  public currentUser$ = this.currentUserSubject.asObservable();\n\n  constructor() {\n    this.loadUsers();\n  }\n\n  getUsers(): Observable<User[]> {\n    return this.users$;\n  }\n\n  getCurrentUser(): Observable<User | null> {\n    return this.currentUser$;\n  }\n\n  setCurrentUser(user: User): void {\n    this.currentUserSubject.next(user);\n  }\n\n  addUser(user: Omit<User, 'id'>): void {\n    const users = this.usersSubject.value;\n    const newUser: User = {\n      ...user,\n      id: Math.max(...users.map(u => u.id), 0) + 1\n    };\n    this.usersSubject.next([...users, newUser]);\n  }\n\n  private loadUsers(): void {\n    // Simulate initial data\n    const initialUsers: User[] = [\n      { id: 1, name: 'John Doe', email: 'john@example.com', role: 'admin' },\n      { id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'user' }\n    ];\n    this.usersSubject.next(initialUsers);\n  }\n}\n\n// user-list.component.ts\nimport { Component, OnInit, inject } from '@angular/core';\nimport { UserService, User } from './user.service';\nimport { Observable } from 'rxjs';\n\n@Component({\n  selector: 'app-user-list',\n  template: `\n    <div class=\"user-list\">\n      <h3>Users</h3>\n      <div *ngFor=\"let user of users$ | async\" class=\"user-card\">\n        <h4>{{ user.name }}</h4>\n        <p>{{ user.email }}</p>\n        <span class=\"role-badge\" [class]=\"user.role\">{{ user.role }}</span>\n        <button (click)=\"selectUser(user)\">Select</button>\n      </div>\n      \n      <div class=\"current-user\" *ngIf=\"currentUser$ | async as currentUser\">\n        <h4>Current User: {{ currentUser.name }}</h4>\n      </div>\n    </div>\n  `,\n  styles: [`\n    .user-list {\n      padding: 20px;\n    }\n    .user-card {\n      border: 1px solid #ddd;\n      padding: 15px;\n      margin: 10px 0;\n      border-radius: 8px;\n    }\n    .role-badge {\n      padding: 4px 8px;\n      border-radius: 4px;\n      font-size: 0.8em;\n      font-weight: bold;\n    }\n    .role-badge.admin {\n      background: #dc3545;\n      color: white;\n    }\n    .role-badge.user {\n      background: #28a745;\n      color: white;\n    }\n    .current-user {\n      margin-top: 20px;\n      padding: 15px;\n      background: #f8f9fa;\n      border-radius: 8px;\n    }\n  `]\n})\nexport class UserListComponent implements OnInit {\n  // Modern injection using inject() function\n  private userService = inject(UserService);\n  \n  users$: Observable<User[]>;\n  currentUser$: Observable<User | null>;\n\n  constructor() {\n    // Alternative: Traditional constructor injection\n    // constructor(private userService: UserService) {}\n  }\n\n  ngOnInit(): void {\n    this.users$ = this.userService.getUsers();\n    this.currentUser$ = this.userService.getCurrentUser();\n  }\n\n  selectUser(user: User): void {\n    this.userService.setCurrentUser(user);\n  }\n}",
      "explanation": "This example shows how to create a service with @Injectable and inject it into a component using both traditional constructor injection and the modern inject() function."
    },
    {
      "title": "Different Provider Scopes",
      "language": "typescript",
      "code": "// logger.service.ts\nimport { Injectable, InjectionToken } from '@angular/core';\n\n// Injection token for configuration\nexport const LOGGER_CONFIG = new InjectionToken<LoggerConfig>('logger.config');\n\nexport interface LoggerConfig {\n  level: 'debug' | 'info' | 'warn' | 'error';\n  enableConsole: boolean;\n  enableRemote: boolean;\n}\n\n@Injectable()\nexport class LoggerService {\n  constructor(@Inject(LOGGER_CONFIG) private config: LoggerConfig) {}\n\n  debug(message: string, ...args: any[]): void {\n    if (this.shouldLog('debug')) {\n      console.debug(`[DEBUG] ${message}`, ...args);\n    }\n  }\n\n  info(message: string, ...args: any[]): void {\n    if (this.shouldLog('info')) {\n      console.info(`[INFO] ${message}`, ...args);\n    }\n  }\n\n  warn(message: string, ...args: any[]): void {\n    if (this.shouldLog('warn')) {\n      console.warn(`[WARN] ${message}`, ...args);\n    }\n  }\n\n  error(message: string, ...args: any[]): void {\n    if (this.shouldLog('error')) {\n      console.error(`[ERROR] ${message}`, ...args);\n    }\n  }\n\n  private shouldLog(level: string): boolean {\n    const levels = ['debug', 'info', 'warn', 'error'];\n    const configLevel = levels.indexOf(this.config.level);\n    const messageLevel = levels.indexOf(level);\n    return messageLevel >= configLevel && this.config.enableConsole;\n  }\n}\n\n// app.config.ts (Angular 17+ standalone)\nimport { ApplicationConfig } from '@angular/core';\nimport { LoggerService, LOGGER_CONFIG } from './logger.service';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    // Root level providers (singleton across entire app)\n    {\n      provide: LOGGER_CONFIG,\n      useValue: {\n        level: 'info',\n        enableConsole: true,\n        enableRemote: false\n      }\n    },\n    LoggerService,\n    \n    // Other providers...\n  ]\n};\n\n// feature.component.ts\nimport { Component } from '@angular/core';\nimport { LoggerService, LOGGER_CONFIG } from './logger.service';\n\n@Component({\n  selector: 'app-feature',\n  template: `\n    <div class=\"feature\">\n      <h3>Feature Component</h3>\n      <button (click)=\"testLogging()\">Test Logging</button>\n    </div>\n  `,\n  providers: [\n    // Component-level providers (new instance per component)\n    {\n      provide: LOGGER_CONFIG,\n      useValue: {\n        level: 'debug',\n        enableConsole: true,\n        enableRemote: true\n      }\n    },\n    LoggerService // This component gets its own LoggerService instance\n  ]\n})\nexport class FeatureComponent {\n  constructor(private logger: LoggerService) {}\n\n  testLogging(): void {\n    this.logger.debug('Debug message from feature component');\n    this.logger.info('Info message from feature component');\n    this.logger.warn('Warning message from feature component');\n    this.logger.error('Error message from feature component');\n  }\n}",
      "explanation": "This example demonstrates different provider scopes: root-level singleton services, component-level instances, and injection tokens for configuration."
    }
  ],
  "exercises": [
    {
      "title": "Build a Shopping Cart Service with DI",
      "description": "Create a shopping cart service that manages cart items and is properly injected across components.",
      "hints": [
        "Create interfaces for Product and CartItem",
        "Use @Injectable with providedIn: 'root'",
        "Implement add, remove, and clear functionality",
        "Use BehaviorSubject for reactive updates",
        "Calculate total price and item count"
      ],
      "solution": "// models/product.interface.ts\nexport interface Product {\n  id: number;\n  name: string;\n  price: number;\n  description: string;\n  image?: string;\n  category: string;\n}\n\nexport interface CartItem {\n  product: Product;\n  quantity: number;\n  totalPrice: number;\n}\n\n// services/shopping-cart.service.ts\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { Product, CartItem } from '../models/product.interface';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ShoppingCartService {\n  private cartItemsSubject = new BehaviorSubject<CartItem[]>([]);\n  public cartItems$ = this.cartItemsSubject.asObservable();\n  \n  public totalItems$ = this.cartItems$.pipe(\n    map(items => items.reduce((sum, item) => sum + item.quantity, 0))\n  );\n  \n  public totalPrice$ = this.cartItems$.pipe(\n    map(items => items.reduce((sum, item) => sum + item.totalPrice, 0))\n  );\n\n  constructor() {\n    this.loadCartFromStorage();\n  }\n\n  addToCart(product: Product, quantity: number = 1): void {\n    const currentItems = this.cartItemsSubject.value;\n    const existingItemIndex = currentItems.findIndex(item => item.product.id === product.id);\n    \n    if (existingItemIndex >= 0) {\n      // Update existing item\n      const updatedItems = [...currentItems];\n      updatedItems[existingItemIndex] = {\n        ...updatedItems[existingItemIndex],\n        quantity: updatedItems[existingItemIndex].quantity + quantity,\n        totalPrice: (updatedItems[existingItemIndex].quantity + quantity) * product.price\n      };\n      this.cartItemsSubject.next(updatedItems);\n    } else {\n      // Add new item\n      const newItem: CartItem = {\n        product,\n        quantity,\n        totalPrice: product.price * quantity\n      };\n      this.cartItemsSubject.next([...currentItems, newItem]);\n    }\n    \n    this.saveCartToStorage();\n  }\n\n  removeFromCart(productId: number): void {\n    const currentItems = this.cartItemsSubject.value;\n    const updatedItems = currentItems.filter(item => item.product.id !== productId);\n    this.cartItemsSubject.next(updatedItems);\n    this.saveCartToStorage();\n  }\n\n  updateQuantity(productId: number, quantity: number): void {\n    if (quantity <= 0) {\n      this.removeFromCart(productId);\n      return;\n    }\n    \n    const currentItems = this.cartItemsSubject.value;\n    const updatedItems = currentItems.map(item => {\n      if (item.product.id === productId) {\n        return {\n          ...item,\n          quantity,\n          totalPrice: item.product.price * quantity\n        };\n      }\n      return item;\n    });\n    \n    this.cartItemsSubject.next(updatedItems);\n    this.saveCartToStorage();\n  }\n\n  clearCart(): void {\n    this.cartItemsSubject.next([]);\n    this.saveCartToStorage();\n  }\n\n  getCartItems(): Observable<CartItem[]> {\n    return this.cartItems$;\n  }\n\n  getTotalItems(): Observable<number> {\n    return this.totalItems$;\n  }\n\n  getTotalPrice(): Observable<number> {\n    return this.totalPrice$;\n  }\n\n  private saveCartToStorage(): void {\n    const cartData = this.cartItemsSubject.value;\n    localStorage.setItem('shopping-cart', JSON.stringify(cartData));\n  }\n\n  private loadCartFromStorage(): void {\n    const savedCart = localStorage.getItem('shopping-cart');\n    if (savedCart) {\n      try {\n        const cartData = JSON.parse(savedCart);\n        this.cartItemsSubject.next(cartData);\n      } catch (error) {\n        console.error('Failed to load cart from storage:', error);\n      }\n    }\n  }\n}\n\n// components/cart.component.ts\nimport { Component, OnInit, inject } from '@angular/core';\nimport { ShoppingCartService } from '../services/shopping-cart.service';\nimport { CartItem } from '../models/product.interface';\nimport { Observable } from 'rxjs';\n\n@Component({\n  selector: 'app-cart',\n  template: `\n    <div class=\"cart\">\n      <h3>Shopping Cart</h3>\n      \n      <div class=\"cart-summary\">\n        <p>Total Items: {{ totalItems$ | async }}</p>\n        <p>Total Price: ${{ (totalPrice$ | async) | number:'1.2-2' }}</p>\n      </div>\n      \n      <div class=\"cart-items\">\n        <div *ngFor=\"let item of cartItems$ | async\" class=\"cart-item\">\n          <div class=\"item-info\">\n            <h4>{{ item.product.name }}</h4>\n            <p>${{ item.product.price | number:'1.2-2' }} each</p>\n          </div>\n          \n          <div class=\"item-controls\">\n            <button (click)=\"updateQuantity(item.product.id, item.quantity - 1)\">-</button>\n            <span>{{ item.quantity }}</span>\n            <button (click)=\"updateQuantity(item.product.id, item.quantity + 1)\">+</button>\n          </div>\n          \n          <div class=\"item-total\">\n            ${{ item.totalPrice | number:'1.2-2' }}\n          </div>\n          \n          <button (click)=\"removeItem(item.product.id)\" class=\"remove-btn\">Remove</button>\n        </div>\n      </div>\n      \n      <div class=\"cart-actions\">\n        <button (click)=\"clearCart()\" class=\"clear-btn\">Clear Cart</button>\n        <button (click)=\"checkout()\" class=\"checkout-btn\">Checkout</button>\n      </div>\n    </div>\n  `,\n  styles: [`\n    .cart {\n      padding: 20px;\n      max-width: 600px;\n      margin: 0 auto;\n    }\n    .cart-summary {\n      background: #f8f9fa;\n      padding: 15px;\n      border-radius: 8px;\n      margin-bottom: 20px;\n    }\n    .cart-item {\n      display: flex;\n      align-items: center;\n      padding: 15px;\n      border-bottom: 1px solid #eee;\n      gap: 15px;\n    }\n    .item-info {\n      flex: 1;\n    }\n    .item-controls {\n      display: flex;\n      align-items: center;\n      gap: 10px;\n    }\n    .item-controls button {\n      width: 30px;\n      height: 30px;\n      border: 1px solid #ddd;\n      background: white;\n      cursor: pointer;\n    }\n    .remove-btn {\n      background: #dc3545;\n      color: white;\n      border: none;\n      padding: 8px 12px;\n      border-radius: 4px;\n      cursor: pointer;\n    }\n    .cart-actions {\n      margin-top: 20px;\n      display: flex;\n      gap: 10px;\n    }\n    .clear-btn {\n      background: #6c757d;\n      color: white;\n      border: none;\n      padding: 10px 20px;\n      border-radius: 4px;\n      cursor: pointer;\n    }\n    .checkout-btn {\n      background: #28a745;\n      color: white;\n      border: none;\n      padding: 10px 20px;\n      border-radius: 4px;\n      cursor: pointer;\n      flex: 1;\n    }\n  `]\n})\nexport class CartComponent implements OnInit {\n  private cartService = inject(ShoppingCartService);\n  \n  cartItems$!: Observable<CartItem[]>;\n  totalItems$!: Observable<number>;\n  totalPrice$!: Observable<number>;\n\n  ngOnInit(): void {\n    this.cartItems$ = this.cartService.getCartItems();\n    this.totalItems$ = this.cartService.getTotalItems();\n    this.totalPrice$ = this.cartService.getTotalPrice();\n  }\n\n  updateQuantity(productId: number, quantity: number): void {\n    this.cartService.updateQuantity(productId, quantity);\n  }\n\n  removeItem(productId: number): void {\n    this.cartService.removeFromCart(productId);\n  }\n\n  clearCart(): void {\n    this.cartService.clearCart();\n  }\n\n  checkout(): void {\n    // Implement checkout logic\n    console.log('Proceeding to checkout...');\n  }\n}"
    }
  ],
  "nextSection": "forms-reactive",
  "previousSection": "component-lifecycle"
}